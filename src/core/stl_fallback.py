"""
Fallback STL export functions for when Open3D is not available
"""

import numpy as np
import struct
from typing import Optional, Tuple

def write_stl_manual(vertices: np.ndarray, faces: np.ndarray, filename: str, ascii_format: bool = False) -> bool:
    """
    Manually write STL file without Open3D dependency
    
    Args:
        vertices: Nx3 array of vertex coordinates
        faces: Mx3 array of face indices
        filename: Output filename
        ascii_format: Use ASCII format instead of binary
    
    Returns:
        Success status
    """
    try:
        if ascii_format:
            return _write_stl_ascii(vertices, faces, filename)
        else:
            return _write_stl_binary(vertices, faces, filename)
    except Exception as e:
        print(f"Error writing STL: {e}")
        return False

def _write_stl_ascii(vertices: np.ndarray, faces: np.ndarray, filename: str) -> bool:
    """Write ASCII STL file"""
    with open(filename, 'w') as f:
        f.write("solid mesh\n")
        
        for face in faces:
            # Get face vertices
            v0, v1, v2 = vertices[face[0]], vertices[face[1]], vertices[face[2]]
            
            # Calculate normal
            normal = np.cross(v1 - v0, v2 - v0)
            normal = normal / np.linalg.norm(normal) if np.linalg.norm(normal) > 0 else np.zeros(3)
            
            f.write(f"  facet normal {normal[0]:.6e} {normal[1]:.6e} {normal[2]:.6e}\n")
            f.write("    outer loop\n")
            f.write(f"      vertex {v0[0]:.6e} {v0[1]:.6e} {v0[2]:.6e}\n")
            f.write(f"      vertex {v1[0]:.6e} {v1[1]:.6e} {v1[2]:.6e}\n")
            f.write(f"      vertex {v2[0]:.6e} {v2[1]:.6e} {v2[2]:.6e}\n")
            f.write("    endloop\n")
            f.write("  endfacet\n")
        
        f.write("endsolid mesh\n")
    
    print(f"ASCII STL written to {filename}")
    return True

def _write_stl_binary(vertices: np.ndarray, faces: np.ndarray, filename: str) -> bool:
    """Write binary STL file"""
    with open(filename, 'wb') as f:
        # Write header (80 bytes)
        header = b'STL generated by JScaner' + b'\0' * (80 - len(b'STL generated by JScaner'))
        f.write(header)
        
        # Write number of triangles
        f.write(struct.pack('<I', len(faces)))
        
        # Write triangles
        for face in faces:
            # Get face vertices
            v0, v1, v2 = vertices[face[0]], vertices[face[1]], vertices[face[2]]
            
            # Calculate normal
            normal = np.cross(v1 - v0, v2 - v0)
            normal = normal / np.linalg.norm(normal) if np.linalg.norm(normal) > 0 else np.zeros(3)
            
            # Write normal (3 floats)
            f.write(struct.pack('<fff', normal[0], normal[1], normal[2]))
            
            # Write vertices (9 floats)
            f.write(struct.pack('<fff', v0[0], v0[1], v0[2]))
            f.write(struct.pack('<fff', v1[0], v1[1], v1[2]))
            f.write(struct.pack('<fff', v2[0], v2[1], v2[2]))
            
            # Write attribute byte count (2 bytes, always 0)
            f.write(struct.pack('<H', 0))
    
    print(f"Binary STL written to {filename}")
    return True

def extract_mesh_data(mesh_obj) -> Optional[Tuple[np.ndarray, np.ndarray]]:
    """
    Extract vertices and faces from mesh object
    
    Args:
        mesh_obj: Mesh object (various formats)
    
    Returns:
        Tuple of (vertices, faces) or None if failed
    """
    try:
        if hasattr(mesh_obj, 'vertices') and hasattr(mesh_obj, 'faces'):
            # Trimesh format
            vertices = np.asarray(mesh_obj.vertices)
            faces = np.asarray(mesh_obj.faces)
            return vertices, faces
        elif hasattr(mesh_obj, 'vertex_matrix'):
            # PyMeshLab format
            vertices = mesh_obj.vertex_matrix()
            faces = mesh_obj.face_matrix()
            return vertices, faces
        else:
            print(f"Unknown mesh format: {type(mesh_obj)}")
            return None
            
    except Exception as e:
        print(f"Error extracting mesh data: {e}")
        return None

def write_point_cloud_ply(points: np.ndarray, filename: str, colors: Optional[np.ndarray] = None) -> bool:
    """
    Write point cloud to PLY format as fallback
    
    Args:
        points: Nx3 array of point coordinates
        filename: Output filename
        colors: Nx3 array of RGB colors (optional)
    
    Returns:
        Success status
    """
    try:
        with open(filename, 'w') as f:
            # PLY header
            f.write("ply\n")
            f.write("format ascii 1.0\n")
            f.write(f"element vertex {len(points)}\n")
            f.write("property float x\n")
            f.write("property float y\n")
            f.write("property float z\n")
            
            if colors is not None:
                f.write("property uchar red\n")
                f.write("property uchar green\n")
                f.write("property uchar blue\n")
            
            f.write("end_header\n")
            
            # Write vertices
            for i, point in enumerate(points):
                if colors is not None:
                    color = colors[i]
                    f.write(f"{point[0]} {point[1]} {point[2]} {int(color[0])} {int(color[1])} {int(color[2])}\n")
                else:
                    f.write(f"{point[0]} {point[1]} {point[2]}\n")
        
        print(f"Point cloud saved to {filename}")
        return True
        
    except Exception as e:
        print(f"Error writing PLY: {e}")
        return False